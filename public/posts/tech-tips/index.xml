<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech Notes on </title>
    <link>https://bfloeser.netlify.com/posts/tech-tips/</link>
    <description>Recent content in Tech Notes on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://bfloeser.netlify.com/posts/tech-tips/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Working with Python virtual environments</title>
      <link>https://bfloeser.netlify.com/posts/tech-tips/venv/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://bfloeser.netlify.com/posts/tech-tips/venv/</guid>
      <description>Whenever you start a project in Python you probably want to do it in a fresh environment so as not to have your dependencies clash with those of other projects, prevent version mismatch or other unexpected breakage.
The way to do this is by using virtual environments. As far as I know there are several ways to do this in Python (as always&amp;hellip;) but the most prevalent, it seems to me, is using the builtin venv module.</description>
    </item>
    
    <item>
      <title>Managing dotfiles with bare git repo</title>
      <link>https://bfloeser.netlify.com/posts/tech-tips/dotfiles/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://bfloeser.netlify.com/posts/tech-tips/dotfiles/</guid>
      <description>A tale as old as time: you configure and tweak your personal machine that you use for work, coding, fun and games or whatever and at some point you wonder how you might preserve all those tweaks. Either, you want to back them up (which is always sensible) or you want to transfer to a new machine or want to show them to other people online so they can just download your setup and get going immediately.</description>
    </item>
    
    <item>
      <title>Commit to someone else&#39;s pull request</title>
      <link>https://bfloeser.netlify.com/posts/tech-tips/git_other_pr/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bfloeser.netlify.com/posts/tech-tips/git_other_pr/</guid>
      <description>I&amp;rsquo;m currently experiencing the pleasure of collaborating on an open source project with someone else on GitHub and I love doing it. There was an issue with runtime performance and we looked into it, discussed ideas and coded up several prototypic solutions (I admit mine were rather dirty). At one point I reviewed someone else&amp;rsquo;s pull request and wanted to add something to it. Sure, I can use the online editing features of GitHub but that doesn&amp;rsquo;t really tie in well with my code-writing workflow, not to mention that all the autocompletion, linting and inline compiler errors won&amp;rsquo;t be present.</description>
    </item>
    
    <item>
      <title>Running a script on conda activate</title>
      <link>https://bfloeser.netlify.com/posts/tech-tips/conda/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bfloeser.netlify.com/posts/tech-tips/conda/</guid>
      <description>I recently noticed that using a conda environment can come with a couple inconveniences. For example, since the default Python executable changes when activating conda, this means that the $PATH variable has been modified and some software can not be found anymore.
For instance, I can&amp;rsquo;t call PyMol from command line when in a conda environment because it somehow depends on the Python executable, it seems.
I recently installed some software into a conda env, that needs a couple of environment variables to run but which I only really need (or want) when running this software in this conda env because it messes with $PATH and disrupts my workflow otherwise.</description>
    </item>
    
  </channel>
</rss>
